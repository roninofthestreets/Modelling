# -*- coding: utf-8 -*-
"""MM1FINAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eTqnOUXRQLM38QYuZLiBTKQN99PItltT
"""

import random
import matplotlib.pyplot as plt
import numpy as np

def inverse_transform_exp(lambd):
    #rvg
    return -np.log(1 - random.random()) / lambd

def simulate_mm1_queue(lambd, mu, N):
    # M/M/1 queue system function
    time = 0
    num_in_system = 0
    arrivals = []
    departures = []
    waiting_times = []
    times_customers_seen = []
    departures_customers_seen = []
    busy_periods = []
    is_busy = False #set startin
    busy_start_time = 0#counter

    while len(departures) < N:
        if num_in_system == 0:
            next_arrival = time + inverse_transform_exp(lambd)#firstinstance
            next_departure = float('inf')
        else:
            next_arrival = time + inverse_transform_exp(lambd)##addsub
            next_departure = time + inverse_transform_exp(mu)

        if next_arrival < next_departure:
            time = next_arrival
            num_in_system += 1
            arrivals.append(time)
            times_customers_seen.append(num_in_system - 1)
            if num_in_system == 1:
                is_busy = True
                busy_start_time = time
        else:
            time = next_departure
            num_in_system -= 1
            departures.append(time)
            departures_customers_seen.append(num_in_system)
            waiting_times.append(time - arrivals[len(departures) - 1])
            if num_in_system == 0:
                busy_periods.append(time - busy_start_time)
                is_busy = False

    return times_customers_seen, departures_customers_seen, busy_periods, waiting_times

def calculate_ccdf(data):
    #this thing
    counts, bin_edges = np.histogram(data, bins='auto', density=True)
    ccdf = np.cumsum(counts[::-1])[::-1]
    ccdf /= ccdf[0]
    return bin_edges[1:], ccdf

def plot_ccdf(data, lambdas, title, ylabel, theoretical=None):
    #plots
    plt.figure(figsize=(10, 6))
    for i, lambd in enumerate(lambdas):
        x, y = calculate_ccdf(data[i])
        plt.step(x, y, where='post', label=f'λ = {lambd}')

        if theoretical:
            theoretical_y = [theoretical(lambd, xi) for xi in x]
            plt.plot(x, theoretical_y, '--', label=f'Theoretical λ = {lambd}')

    plt.yscale('log')
    plt.xlabel('Number of Customers')
    plt.ylabel(ylabel)
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

def main():
    N = 10000
    mu = 1
    lambdas = [0.7, 0.8, 0.9, 0.95]
    K = 10
    all_arrival_ccdfs = [[] for _ in lambdas]
    all_departure_ccdfs = [[] for _ in lambdas]
    all_busy_period_ccdfs = [[] for _ in lambdas]

    for i, lambd in enumerate(lambdas):
        for _ in range(K):
            random.seed()  # seeds for sim
            arrivals, departures, busy_periods, _ = simulate_mm1_queue(lambd, mu, N)
            all_arrival_ccdfs[i].extend(arrivals)
            all_departure_ccdfs[i].extend(departures)
            all_busy_period_ccdfs[i].extend(busy_periods)

    plot_ccdf(all_arrival_ccdfs, lambdas, 'CCDF of Arrivals', 'P{X(t_i) ≥ n}', theoretical=lambda l, k: l**k)
    plot_ccdf(all_departure_ccdfs, lambdas, 'CCDF of Departures', 'P{D_i ≥ n}',theoretical =lambda l,k: l**k)
    plot_ccdf(all_busy_period_ccdfs, lambdas, 'CCDF of Busy Periods', 'P{B_i ≥ n}')

if __name__ == "__main__":
    main()